/* tslint:disable */
/* eslint-disable */
/**
 * Sniptt API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddMemberToVaultRequest
 */
export interface AddMemberToVaultRequest {
    /**
     * 
     * @type {string}
     * @memberof AddMemberToVaultRequest
     */
    AccountEmail: string;
    /**
     * 
     * @type {string}
     * @memberof AddMemberToVaultRequest
     */
    Role: string;
    /**
     * 
     * @type {string}
     * @memberof AddMemberToVaultRequest
     */
    VaultEncryptedPrivateKey: string;
    /**
     * 
     * @type {string}
     * @memberof AddMemberToVaultRequest
     */
    VaultId: string;
}
/**
 * 
 * @export
 * @interface AddSecretRequest
 */
export interface AddSecretRequest {
    /**
     * 
     * @type {string}
     * @memberof AddSecretRequest
     */
    SecretName: string;
    /**
     * 
     * @type {string}
     * @memberof AddSecretRequest
     */
    SecretContentType: string;
    /**
     * 
     * @type {string}
     * @memberof AddSecretRequest
     */
    VaultId: string;
    /**
     * 
     * @type {string}
     * @memberof AddSecretRequest
     */
    SecretEncryptedContent: string;
}
/**
 * 
 * @export
 * @interface AddSecretResponse
 */
export interface AddSecretResponse {
    /**
     * 
     * @type {string}
     * @memberof AddSecretResponse
     */
    SecretId: string;
}
/**
 * 
 * @export
 * @interface ConfigureAccountRequest
 */
export interface ConfigureAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfigureAccountRequest
     */
    PersonalVaultEncryptedPrivateKey: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigureAccountRequest
     */
    PersonalVaultPublicKey: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigureAccountRequest
     */
    AccountPublicKey: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigureAccountRequest
     */
    AccountName: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigureAccountRequest
     */
    AccountEncryptionKeySalt: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigureAccountRequest
     */
    AccountEncryptedPrivateKey: string;
}
/**
 * 
 * @export
 * @interface ConfigureAccountResponse
 */
export interface ConfigureAccountResponse {
    /**
     * 
     * @type {string}
     * @memberof ConfigureAccountResponse
     */
    AccountId: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigureAccountResponse
     */
    PersonalVaultId: string;
}
/**
 * 
 * @export
 * @interface CreateOneTimeSecretRequest
 */
export interface CreateOneTimeSecretRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateOneTimeSecretRequest
     */
    OneTimeSecretPublicKey: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOneTimeSecretRequest
     */
    OneTimeSecretEncryptedPrivateKey: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOneTimeSecretRequest
     */
    OneTimeSecretContentType: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOneTimeSecretRequest
     */
    OneTimeSecretEncryptedContent: string;
}
/**
 * 
 * @export
 * @interface CreateOneTimeSecretResponse
 */
export interface CreateOneTimeSecretResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateOneTimeSecretResponse
     */
    OneTimeSecretId: string;
}
/**
 * 
 * @export
 * @interface CreateVaultRequest
 */
export interface CreateVaultRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateVaultRequest
     */
    VaultName: string;
    /**
     * 
     * @type {string}
     * @memberof CreateVaultRequest
     */
    VaultEncryptedPrivateKey: string;
    /**
     * 
     * @type {string}
     * @memberof CreateVaultRequest
     */
    VaultPublicKey: string;
}
/**
 * 
 * @export
 * @interface CreateVaultResponse
 */
export interface CreateVaultResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateVaultResponse
     */
    VaultId: string;
}
/**
 * 
 * @export
 * @interface DeleteSecretRequest
 */
export interface DeleteSecretRequest {
    /**
     * 
     * @type {string}
     * @memberof DeleteSecretRequest
     */
    SecretName: string;
    /**
     * 
     * @type {string}
     * @memberof DeleteSecretRequest
     */
    VaultId: string;
}
/**
 * 
 * @export
 * @interface ListVaultMembersRequest
 */
export interface ListVaultMembersRequest {
    /**
     * 
     * @type {string}
     * @memberof ListVaultMembersRequest
     */
    VaultId: string;
}
/**
 * 
 * @export
 * @interface ListVaultMembersResponse
 */
export interface ListVaultMembersResponse extends Array<VaultMember> {
}
/**
 * 
 * @export
 * @interface ListVaultMembershipsResponse
 */
export interface ListVaultMembershipsResponse extends Array<VaultMembership> {
}
/**
 * 
 * @export
 * @interface ListVaultSecretsRequest
 */
export interface ListVaultSecretsRequest {
    /**
     * 
     * @type {string}
     * @memberof ListVaultSecretsRequest
     */
    VaultId: string;
}
/**
 * 
 * @export
 * @interface ListVaultSecretsResponse
 */
export interface ListVaultSecretsResponse extends Array<VaultSecret> {
}
/**
 * 
 * @export
 * @interface RegisterDeviceRequest
 */
export interface RegisterDeviceRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterDeviceRequest
     */
    Email: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterDeviceRequest
     */
    Code: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterDeviceRequest
     */
    DeviceName: string;
}
/**
 * 
 * @export
 * @interface RegisterDeviceResponse
 */
export interface RegisterDeviceResponse {
    /**
     * 
     * @type {string}
     * @memberof RegisterDeviceResponse
     */
    ApiKey: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterDeviceResponse
     */
    AccountId: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterDeviceResponse
     */
    DeviceId: string;
    /**
     * 
     * @type {boolean}
     * @memberof RegisterDeviceResponse
     */
    IsAccountConfigured: boolean;
}
/**
 * 
 * @export
 * @interface RemoveMemberFromVaultRequest
 */
export interface RemoveMemberFromVaultRequest {
    /**
     * 
     * @type {string}
     * @memberof RemoveMemberFromVaultRequest
     */
    AccountEmail: string;
    /**
     * 
     * @type {string}
     * @memberof RemoveMemberFromVaultRequest
     */
    VaultEncryptedPrivateKey: string;
    /**
     * 
     * @type {string}
     * @memberof RemoveMemberFromVaultRequest
     */
    VaultId: string;
}
/**
 * 
 * @export
 * @interface RetrieveAccountConfigurationResponse
 */
export interface RetrieveAccountConfigurationResponse {
    /**
     * 
     * @type {string}
     * @memberof RetrieveAccountConfigurationResponse
     */
    AccountId: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAccountConfigurationResponse
     */
    PersonalVaultId: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAccountConfigurationResponse
     */
    AccountTier: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAccountConfigurationResponse
     */
    PersonalVaultEncryptedPrivateKey: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAccountConfigurationResponse
     */
    AccountEmail: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAccountConfigurationResponse
     */
    PersonalVaultPublicKey: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAccountConfigurationResponse
     */
    AccountPublicKey: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAccountConfigurationResponse
     */
    AccountEncryptedPrivateKey: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAccountConfigurationResponse
     */
    AccountName: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAccountConfigurationResponse
     */
    AccountEncryptionKeySalt: string;
}
/**
 * 
 * @export
 * @interface RetrieveAccountPublicKeyRequest
 */
export interface RetrieveAccountPublicKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof RetrieveAccountPublicKeyRequest
     */
    AccountEmail: string;
}
/**
 * 
 * @export
 * @interface RetrieveAccountPublicKeyResponse
 */
export interface RetrieveAccountPublicKeyResponse {
    /**
     * 
     * @type {string}
     * @memberof RetrieveAccountPublicKeyResponse
     */
    AccountId: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAccountPublicKeyResponse
     */
    AccountPublicKey: string;
}
/**
 * 
 * @export
 * @interface RetrieveOneTimeSecretRequest
 */
export interface RetrieveOneTimeSecretRequest {
    /**
     * 
     * @type {string}
     * @memberof RetrieveOneTimeSecretRequest
     */
    OneTimeSecretId: string;
}
/**
 * 
 * @export
 * @interface RetrieveOneTimeSecretResponse
 */
export interface RetrieveOneTimeSecretResponse {
    /**
     * 
     * @type {string}
     * @memberof RetrieveOneTimeSecretResponse
     */
    OneTimeSecretPublicKey: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieveOneTimeSecretResponse
     */
    OneTimeSecretId: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieveOneTimeSecretResponse
     */
    OneTimeSecretEncryptedPrivateKey: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieveOneTimeSecretResponse
     */
    OneTimeSecretEncryptedContent: string;
}
/**
 * 
 * @export
 * @interface RetrieveSecretRequest
 */
export interface RetrieveSecretRequest {
    /**
     * 
     * @type {string}
     * @memberof RetrieveSecretRequest
     */
    SecretName: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieveSecretRequest
     */
    VaultId: string;
}
/**
 * 
 * @export
 * @interface RetrieveSecretResponse
 */
export interface RetrieveSecretResponse {
    /**
     * 
     * @type {string}
     * @memberof RetrieveSecretResponse
     */
    SecretName: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieveSecretResponse
     */
    SecretContentType: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieveSecretResponse
     */
    SecretId: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieveSecretResponse
     */
    SecretEncryptedContent: string;
}
/**
 * 
 * @export
 * @interface RetrieveVaultKeysRequest
 */
export interface RetrieveVaultKeysRequest {
    /**
     * 
     * @type {string}
     * @memberof RetrieveVaultKeysRequest
     */
    VaultId: string;
}
/**
 * 
 * @export
 * @interface RetrieveVaultKeysResponse
 */
export interface RetrieveVaultKeysResponse {
    /**
     * 
     * @type {string}
     * @memberof RetrieveVaultKeysResponse
     */
    VaultEncryptedPrivateKey: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieveVaultKeysResponse
     */
    VaultPublicKey: string;
}
/**
 * 
 * @export
 * @interface SearchVaultMembershipsRequest
 */
export interface SearchVaultMembershipsRequest {
    /**
     * 
     * @type {string}
     * @memberof SearchVaultMembershipsRequest
     */
    VaultName: string;
}
/**
 * 
 * @export
 * @interface SearchVaultMembershipsResponse
 */
export interface SearchVaultMembershipsResponse extends Array<VaultMembership> {
}
/**
 * 
 * @export
 * @interface SendEmailVerificationCodeRequest
 */
export interface SendEmailVerificationCodeRequest {
    /**
     * 
     * @type {string}
     * @memberof SendEmailVerificationCodeRequest
     */
    Email: string;
}
/**
 * 
 * @export
 * @interface VaultMember
 */
export interface VaultMember {
    /**
     * 
     * @type {string}
     * @memberof VaultMember
     */
    Role: string;
    /**
     * 
     * @type {string}
     * @memberof VaultMember
     */
    AccountId: string;
    /**
     * 
     * @type {string}
     * @memberof VaultMember
     */
    AccountEmail: string;
    /**
     * 
     * @type {string}
     * @memberof VaultMember
     */
    AccountPublicKey: string;
    /**
     * 
     * @type {string}
     * @memberof VaultMember
     */
    AccountName: string;
}
/**
 * 
 * @export
 * @interface VaultMembership
 */
export interface VaultMembership {
    /**
     * 
     * @type {string}
     * @memberof VaultMembership
     */
    Role: string;
    /**
     * 
     * @type {string}
     * @memberof VaultMembership
     */
    VaultOwnerAccountId: string;
    /**
     * 
     * @type {string}
     * @memberof VaultMembership
     */
    VaultName: string;
    /**
     * 
     * @type {string}
     * @memberof VaultMembership
     */
    VaultOwnerAccountEmail: string;
    /**
     * 
     * @type {string}
     * @memberof VaultMembership
     */
    VaultId: string;
    /**
     * 
     * @type {string}
     * @memberof VaultMembership
     */
    VaultOwnerAccountName: string;
}
/**
 * 
 * @export
 * @interface VaultSecret
 */
export interface VaultSecret {
    /**
     * 
     * @type {string}
     * @memberof VaultSecret
     */
    SecretName: string;
    /**
     * 
     * @type {string}
     * @memberof VaultSecret
     */
    SecretOwnerAccountName: string;
    /**
     * 
     * @type {string}
     * @memberof VaultSecret
     */
    SecretOwnerAccountEmail: string;
    /**
     * 
     * @type {string}
     * @memberof VaultSecret
     */
    SecretId: string;
    /**
     * 
     * @type {string}
     * @memberof VaultSecret
     */
    SecretOwnerAccountId: string;
}

/**
 * SnipttApi - axios parameter creator
 * @export
 */
export const SnipttApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add member to vault
         * @param {AddMemberToVaultRequest} addMemberToVaultRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMemberToVault: async (addMemberToVaultRequest: AddMemberToVaultRequest, xApiKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'addMemberToVaultRequest' is not null or undefined
            assertParamExists('addMemberToVault', 'addMemberToVaultRequest', addMemberToVaultRequest)
            const localVarPath = `/addMemberToVault`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addMemberToVaultRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add end-to-end encrypted secret to vault
         * @param {AddSecretRequest} addSecretRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSecret: async (addSecretRequest: AddSecretRequest, xApiKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'addSecretRequest' is not null or undefined
            assertParamExists('addSecret', 'addSecretRequest', addSecretRequest)
            const localVarPath = `/addSecret`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addSecretRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Configures Sniptt account
         * @param {ConfigureAccountRequest} configureAccountRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureAccount: async (configureAccountRequest: ConfigureAccountRequest, xApiKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'configureAccountRequest' is not null or undefined
            assertParamExists('configureAccount', 'configureAccountRequest', configureAccountRequest)
            const localVarPath = `/configureAccount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(configureAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create one time secret
         * @param {CreateOneTimeSecretRequest} createOneTimeSecretRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOneTimeSecret: async (createOneTimeSecretRequest: CreateOneTimeSecretRequest, xApiKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOneTimeSecretRequest' is not null or undefined
            assertParamExists('createOneTimeSecret', 'createOneTimeSecretRequest', createOneTimeSecretRequest)
            const localVarPath = `/createOneTimeSecret`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOneTimeSecretRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create vault
         * @param {CreateVaultRequest} createVaultRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVault: async (createVaultRequest: CreateVaultRequest, xApiKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createVaultRequest' is not null or undefined
            assertParamExists('createVault', 'createVaultRequest', createVaultRequest)
            const localVarPath = `/createVault`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVaultRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove end-to-end encrypted secret from vault
         * @param {DeleteSecretRequest} deleteSecretRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSecret: async (deleteSecretRequest: DeleteSecretRequest, xApiKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteSecretRequest' is not null or undefined
            assertParamExists('deleteSecret', 'deleteSecretRequest', deleteSecretRequest)
            const localVarPath = `/deleteSecret`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteSecretRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List vault members
         * @param {ListVaultMembersRequest} listVaultMembersRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVaultMembers: async (listVaultMembersRequest: ListVaultMembersRequest, xApiKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'listVaultMembersRequest' is not null or undefined
            assertParamExists('listVaultMembers', 'listVaultMembersRequest', listVaultMembersRequest)
            const localVarPath = `/listVaultMembers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listVaultMembersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List vault memberships
         * @param {object} body 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVaultMemberships: async (body: object, xApiKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('listVaultMemberships', 'body', body)
            const localVarPath = `/listVaultMemberships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List vault secrets
         * @param {ListVaultSecretsRequest} listVaultSecretsRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVaultSecrets: async (listVaultSecretsRequest: ListVaultSecretsRequest, xApiKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'listVaultSecretsRequest' is not null or undefined
            assertParamExists('listVaultSecrets', 'listVaultSecretsRequest', listVaultSecretsRequest)
            const localVarPath = `/listVaultSecrets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listVaultSecretsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register user device
         * @param {RegisterDeviceRequest} registerDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerDevice: async (registerDeviceRequest: RegisterDeviceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerDeviceRequest' is not null or undefined
            assertParamExists('registerDevice', 'registerDeviceRequest', registerDeviceRequest)
            const localVarPath = `/registerDevice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove member to vault
         * @param {RemoveMemberFromVaultRequest} removeMemberFromVaultRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMemberFromVault: async (removeMemberFromVaultRequest: RemoveMemberFromVaultRequest, xApiKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'removeMemberFromVaultRequest' is not null or undefined
            assertParamExists('removeMemberFromVault', 'removeMemberFromVaultRequest', removeMemberFromVaultRequest)
            const localVarPath = `/removeMemberFromVault`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeMemberFromVaultRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send email verification code
         * @param {object} body 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAccountConfiguration: async (body: object, xApiKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('retrieveAccountConfiguration', 'body', body)
            const localVarPath = `/retrieveAccountConfiguration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve account public key
         * @param {RetrieveAccountPublicKeyRequest} retrieveAccountPublicKeyRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAccountPublicKey: async (retrieveAccountPublicKeyRequest: RetrieveAccountPublicKeyRequest, xApiKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'retrieveAccountPublicKeyRequest' is not null or undefined
            assertParamExists('retrieveAccountPublicKey', 'retrieveAccountPublicKeyRequest', retrieveAccountPublicKeyRequest)
            const localVarPath = `/retrieveAccountPublicKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(retrieveAccountPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve one time secret
         * @param {RetrieveOneTimeSecretRequest} retrieveOneTimeSecretRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOneTimeSecret: async (retrieveOneTimeSecretRequest: RetrieveOneTimeSecretRequest, xApiKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'retrieveOneTimeSecretRequest' is not null or undefined
            assertParamExists('retrieveOneTimeSecret', 'retrieveOneTimeSecretRequest', retrieveOneTimeSecretRequest)
            const localVarPath = `/retrieveOneTimeSecret`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(retrieveOneTimeSecretRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch and decrypt end-to-end encrypted secret from vault
         * @param {RetrieveSecretRequest} retrieveSecretRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSecret: async (retrieveSecretRequest: RetrieveSecretRequest, xApiKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'retrieveSecretRequest' is not null or undefined
            assertParamExists('retrieveSecret', 'retrieveSecretRequest', retrieveSecretRequest)
            const localVarPath = `/retrieveSecret`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(retrieveSecretRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve vault keys
         * @param {RetrieveVaultKeysRequest} retrieveVaultKeysRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveVaultKeys: async (retrieveVaultKeysRequest: RetrieveVaultKeysRequest, xApiKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'retrieveVaultKeysRequest' is not null or undefined
            assertParamExists('retrieveVaultKeys', 'retrieveVaultKeysRequest', retrieveVaultKeysRequest)
            const localVarPath = `/retrieveVaultKeys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(retrieveVaultKeysRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search Vault memberships
         * @param {SearchVaultMembershipsRequest} searchVaultMembershipsRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchVaultMemberships: async (searchVaultMembershipsRequest: SearchVaultMembershipsRequest, xApiKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchVaultMembershipsRequest' is not null or undefined
            assertParamExists('searchVaultMemberships', 'searchVaultMembershipsRequest', searchVaultMembershipsRequest)
            const localVarPath = `/searchVaultMemberships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchVaultMembershipsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send email verification code
         * @param {SendEmailVerificationCodeRequest} sendEmailVerificationCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailVerificationCode: async (sendEmailVerificationCodeRequest: SendEmailVerificationCodeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendEmailVerificationCodeRequest' is not null or undefined
            assertParamExists('sendEmailVerificationCode', 'sendEmailVerificationCodeRequest', sendEmailVerificationCodeRequest)
            const localVarPath = `/sendEmailVerificationCode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendEmailVerificationCodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SnipttApi - functional programming interface
 * @export
 */
export const SnipttApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SnipttApiAxiosParamCreator(configuration)
    return {
        /**
         * Add member to vault
         * @param {AddMemberToVaultRequest} addMemberToVaultRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMemberToVault(addMemberToVaultRequest: AddMemberToVaultRequest, xApiKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMemberToVault(addMemberToVaultRequest, xApiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add end-to-end encrypted secret to vault
         * @param {AddSecretRequest} addSecretRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSecret(addSecretRequest: AddSecretRequest, xApiKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddSecretResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSecret(addSecretRequest, xApiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Configures Sniptt account
         * @param {ConfigureAccountRequest} configureAccountRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configureAccount(configureAccountRequest: ConfigureAccountRequest, xApiKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigureAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configureAccount(configureAccountRequest, xApiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create one time secret
         * @param {CreateOneTimeSecretRequest} createOneTimeSecretRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOneTimeSecret(createOneTimeSecretRequest: CreateOneTimeSecretRequest, xApiKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOneTimeSecretResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOneTimeSecret(createOneTimeSecretRequest, xApiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create vault
         * @param {CreateVaultRequest} createVaultRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVault(createVaultRequest: CreateVaultRequest, xApiKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateVaultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVault(createVaultRequest, xApiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove end-to-end encrypted secret from vault
         * @param {DeleteSecretRequest} deleteSecretRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSecret(deleteSecretRequest: DeleteSecretRequest, xApiKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSecret(deleteSecretRequest, xApiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List vault members
         * @param {ListVaultMembersRequest} listVaultMembersRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVaultMembers(listVaultMembersRequest: ListVaultMembersRequest, xApiKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListVaultMembersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVaultMembers(listVaultMembersRequest, xApiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List vault memberships
         * @param {object} body 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVaultMemberships(body: object, xApiKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListVaultMembershipsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVaultMemberships(body, xApiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List vault secrets
         * @param {ListVaultSecretsRequest} listVaultSecretsRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVaultSecrets(listVaultSecretsRequest: ListVaultSecretsRequest, xApiKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListVaultSecretsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVaultSecrets(listVaultSecretsRequest, xApiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register user device
         * @param {RegisterDeviceRequest} registerDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerDevice(registerDeviceRequest: RegisterDeviceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterDeviceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerDevice(registerDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove member to vault
         * @param {RemoveMemberFromVaultRequest} removeMemberFromVaultRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeMemberFromVault(removeMemberFromVaultRequest: RemoveMemberFromVaultRequest, xApiKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeMemberFromVault(removeMemberFromVaultRequest, xApiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send email verification code
         * @param {object} body 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAccountConfiguration(body: object, xApiKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveAccountConfigurationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAccountConfiguration(body, xApiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve account public key
         * @param {RetrieveAccountPublicKeyRequest} retrieveAccountPublicKeyRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAccountPublicKey(retrieveAccountPublicKeyRequest: RetrieveAccountPublicKeyRequest, xApiKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveAccountPublicKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAccountPublicKey(retrieveAccountPublicKeyRequest, xApiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve one time secret
         * @param {RetrieveOneTimeSecretRequest} retrieveOneTimeSecretRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveOneTimeSecret(retrieveOneTimeSecretRequest: RetrieveOneTimeSecretRequest, xApiKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveOneTimeSecretResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveOneTimeSecret(retrieveOneTimeSecretRequest, xApiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch and decrypt end-to-end encrypted secret from vault
         * @param {RetrieveSecretRequest} retrieveSecretRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSecret(retrieveSecretRequest: RetrieveSecretRequest, xApiKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveSecretResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSecret(retrieveSecretRequest, xApiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve vault keys
         * @param {RetrieveVaultKeysRequest} retrieveVaultKeysRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveVaultKeys(retrieveVaultKeysRequest: RetrieveVaultKeysRequest, xApiKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveVaultKeysResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveVaultKeys(retrieveVaultKeysRequest, xApiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search Vault memberships
         * @param {SearchVaultMembershipsRequest} searchVaultMembershipsRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchVaultMemberships(searchVaultMembershipsRequest: SearchVaultMembershipsRequest, xApiKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchVaultMembershipsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchVaultMemberships(searchVaultMembershipsRequest, xApiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send email verification code
         * @param {SendEmailVerificationCodeRequest} sendEmailVerificationCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendEmailVerificationCode(sendEmailVerificationCodeRequest: SendEmailVerificationCodeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendEmailVerificationCode(sendEmailVerificationCodeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SnipttApi - factory interface
 * @export
 */
export const SnipttApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SnipttApiFp(configuration)
    return {
        /**
         * Add member to vault
         * @param {AddMemberToVaultRequest} addMemberToVaultRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMemberToVault(addMemberToVaultRequest: AddMemberToVaultRequest, xApiKey?: string, options?: any): AxiosPromise<void> {
            return localVarFp.addMemberToVault(addMemberToVaultRequest, xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Add end-to-end encrypted secret to vault
         * @param {AddSecretRequest} addSecretRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSecret(addSecretRequest: AddSecretRequest, xApiKey?: string, options?: any): AxiosPromise<AddSecretResponse> {
            return localVarFp.addSecret(addSecretRequest, xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Configures Sniptt account
         * @param {ConfigureAccountRequest} configureAccountRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureAccount(configureAccountRequest: ConfigureAccountRequest, xApiKey?: string, options?: any): AxiosPromise<ConfigureAccountResponse> {
            return localVarFp.configureAccount(configureAccountRequest, xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create one time secret
         * @param {CreateOneTimeSecretRequest} createOneTimeSecretRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOneTimeSecret(createOneTimeSecretRequest: CreateOneTimeSecretRequest, xApiKey?: string, options?: any): AxiosPromise<CreateOneTimeSecretResponse> {
            return localVarFp.createOneTimeSecret(createOneTimeSecretRequest, xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create vault
         * @param {CreateVaultRequest} createVaultRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVault(createVaultRequest: CreateVaultRequest, xApiKey?: string, options?: any): AxiosPromise<CreateVaultResponse> {
            return localVarFp.createVault(createVaultRequest, xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove end-to-end encrypted secret from vault
         * @param {DeleteSecretRequest} deleteSecretRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSecret(deleteSecretRequest: DeleteSecretRequest, xApiKey?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSecret(deleteSecretRequest, xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * List vault members
         * @param {ListVaultMembersRequest} listVaultMembersRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVaultMembers(listVaultMembersRequest: ListVaultMembersRequest, xApiKey?: string, options?: any): AxiosPromise<ListVaultMembersResponse> {
            return localVarFp.listVaultMembers(listVaultMembersRequest, xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * List vault memberships
         * @param {object} body 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVaultMemberships(body: object, xApiKey?: string, options?: any): AxiosPromise<ListVaultMembershipsResponse> {
            return localVarFp.listVaultMemberships(body, xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * List vault secrets
         * @param {ListVaultSecretsRequest} listVaultSecretsRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVaultSecrets(listVaultSecretsRequest: ListVaultSecretsRequest, xApiKey?: string, options?: any): AxiosPromise<ListVaultSecretsResponse> {
            return localVarFp.listVaultSecrets(listVaultSecretsRequest, xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Register user device
         * @param {RegisterDeviceRequest} registerDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerDevice(registerDeviceRequest: RegisterDeviceRequest, options?: any): AxiosPromise<RegisterDeviceResponse> {
            return localVarFp.registerDevice(registerDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove member to vault
         * @param {RemoveMemberFromVaultRequest} removeMemberFromVaultRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMemberFromVault(removeMemberFromVaultRequest: RemoveMemberFromVaultRequest, xApiKey?: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeMemberFromVault(removeMemberFromVaultRequest, xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Send email verification code
         * @param {object} body 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAccountConfiguration(body: object, xApiKey?: string, options?: any): AxiosPromise<RetrieveAccountConfigurationResponse> {
            return localVarFp.retrieveAccountConfiguration(body, xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve account public key
         * @param {RetrieveAccountPublicKeyRequest} retrieveAccountPublicKeyRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAccountPublicKey(retrieveAccountPublicKeyRequest: RetrieveAccountPublicKeyRequest, xApiKey?: string, options?: any): AxiosPromise<RetrieveAccountPublicKeyResponse> {
            return localVarFp.retrieveAccountPublicKey(retrieveAccountPublicKeyRequest, xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve one time secret
         * @param {RetrieveOneTimeSecretRequest} retrieveOneTimeSecretRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOneTimeSecret(retrieveOneTimeSecretRequest: RetrieveOneTimeSecretRequest, xApiKey?: string, options?: any): AxiosPromise<RetrieveOneTimeSecretResponse> {
            return localVarFp.retrieveOneTimeSecret(retrieveOneTimeSecretRequest, xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch and decrypt end-to-end encrypted secret from vault
         * @param {RetrieveSecretRequest} retrieveSecretRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSecret(retrieveSecretRequest: RetrieveSecretRequest, xApiKey?: string, options?: any): AxiosPromise<RetrieveSecretResponse> {
            return localVarFp.retrieveSecret(retrieveSecretRequest, xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve vault keys
         * @param {RetrieveVaultKeysRequest} retrieveVaultKeysRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveVaultKeys(retrieveVaultKeysRequest: RetrieveVaultKeysRequest, xApiKey?: string, options?: any): AxiosPromise<RetrieveVaultKeysResponse> {
            return localVarFp.retrieveVaultKeys(retrieveVaultKeysRequest, xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Search Vault memberships
         * @param {SearchVaultMembershipsRequest} searchVaultMembershipsRequest 
         * @param {string} [xApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchVaultMemberships(searchVaultMembershipsRequest: SearchVaultMembershipsRequest, xApiKey?: string, options?: any): AxiosPromise<SearchVaultMembershipsResponse> {
            return localVarFp.searchVaultMemberships(searchVaultMembershipsRequest, xApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Send email verification code
         * @param {SendEmailVerificationCodeRequest} sendEmailVerificationCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailVerificationCode(sendEmailVerificationCodeRequest: SendEmailVerificationCodeRequest, options?: any): AxiosPromise<object> {
            return localVarFp.sendEmailVerificationCode(sendEmailVerificationCodeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SnipttApi - object-oriented interface
 * @export
 * @class SnipttApi
 * @extends {BaseAPI}
 */
export class SnipttApi extends BaseAPI {
    /**
     * Add member to vault
     * @param {AddMemberToVaultRequest} addMemberToVaultRequest 
     * @param {string} [xApiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnipttApi
     */
    public addMemberToVault(addMemberToVaultRequest: AddMemberToVaultRequest, xApiKey?: string, options?: any) {
        return SnipttApiFp(this.configuration).addMemberToVault(addMemberToVaultRequest, xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add end-to-end encrypted secret to vault
     * @param {AddSecretRequest} addSecretRequest 
     * @param {string} [xApiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnipttApi
     */
    public addSecret(addSecretRequest: AddSecretRequest, xApiKey?: string, options?: any) {
        return SnipttApiFp(this.configuration).addSecret(addSecretRequest, xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Configures Sniptt account
     * @param {ConfigureAccountRequest} configureAccountRequest 
     * @param {string} [xApiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnipttApi
     */
    public configureAccount(configureAccountRequest: ConfigureAccountRequest, xApiKey?: string, options?: any) {
        return SnipttApiFp(this.configuration).configureAccount(configureAccountRequest, xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create one time secret
     * @param {CreateOneTimeSecretRequest} createOneTimeSecretRequest 
     * @param {string} [xApiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnipttApi
     */
    public createOneTimeSecret(createOneTimeSecretRequest: CreateOneTimeSecretRequest, xApiKey?: string, options?: any) {
        return SnipttApiFp(this.configuration).createOneTimeSecret(createOneTimeSecretRequest, xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create vault
     * @param {CreateVaultRequest} createVaultRequest 
     * @param {string} [xApiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnipttApi
     */
    public createVault(createVaultRequest: CreateVaultRequest, xApiKey?: string, options?: any) {
        return SnipttApiFp(this.configuration).createVault(createVaultRequest, xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove end-to-end encrypted secret from vault
     * @param {DeleteSecretRequest} deleteSecretRequest 
     * @param {string} [xApiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnipttApi
     */
    public deleteSecret(deleteSecretRequest: DeleteSecretRequest, xApiKey?: string, options?: any) {
        return SnipttApiFp(this.configuration).deleteSecret(deleteSecretRequest, xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List vault members
     * @param {ListVaultMembersRequest} listVaultMembersRequest 
     * @param {string} [xApiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnipttApi
     */
    public listVaultMembers(listVaultMembersRequest: ListVaultMembersRequest, xApiKey?: string, options?: any) {
        return SnipttApiFp(this.configuration).listVaultMembers(listVaultMembersRequest, xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List vault memberships
     * @param {object} body 
     * @param {string} [xApiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnipttApi
     */
    public listVaultMemberships(body: object, xApiKey?: string, options?: any) {
        return SnipttApiFp(this.configuration).listVaultMemberships(body, xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List vault secrets
     * @param {ListVaultSecretsRequest} listVaultSecretsRequest 
     * @param {string} [xApiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnipttApi
     */
    public listVaultSecrets(listVaultSecretsRequest: ListVaultSecretsRequest, xApiKey?: string, options?: any) {
        return SnipttApiFp(this.configuration).listVaultSecrets(listVaultSecretsRequest, xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register user device
     * @param {RegisterDeviceRequest} registerDeviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnipttApi
     */
    public registerDevice(registerDeviceRequest: RegisterDeviceRequest, options?: any) {
        return SnipttApiFp(this.configuration).registerDevice(registerDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove member to vault
     * @param {RemoveMemberFromVaultRequest} removeMemberFromVaultRequest 
     * @param {string} [xApiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnipttApi
     */
    public removeMemberFromVault(removeMemberFromVaultRequest: RemoveMemberFromVaultRequest, xApiKey?: string, options?: any) {
        return SnipttApiFp(this.configuration).removeMemberFromVault(removeMemberFromVaultRequest, xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send email verification code
     * @param {object} body 
     * @param {string} [xApiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnipttApi
     */
    public retrieveAccountConfiguration(body: object, xApiKey?: string, options?: any) {
        return SnipttApiFp(this.configuration).retrieveAccountConfiguration(body, xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve account public key
     * @param {RetrieveAccountPublicKeyRequest} retrieveAccountPublicKeyRequest 
     * @param {string} [xApiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnipttApi
     */
    public retrieveAccountPublicKey(retrieveAccountPublicKeyRequest: RetrieveAccountPublicKeyRequest, xApiKey?: string, options?: any) {
        return SnipttApiFp(this.configuration).retrieveAccountPublicKey(retrieveAccountPublicKeyRequest, xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve one time secret
     * @param {RetrieveOneTimeSecretRequest} retrieveOneTimeSecretRequest 
     * @param {string} [xApiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnipttApi
     */
    public retrieveOneTimeSecret(retrieveOneTimeSecretRequest: RetrieveOneTimeSecretRequest, xApiKey?: string, options?: any) {
        return SnipttApiFp(this.configuration).retrieveOneTimeSecret(retrieveOneTimeSecretRequest, xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch and decrypt end-to-end encrypted secret from vault
     * @param {RetrieveSecretRequest} retrieveSecretRequest 
     * @param {string} [xApiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnipttApi
     */
    public retrieveSecret(retrieveSecretRequest: RetrieveSecretRequest, xApiKey?: string, options?: any) {
        return SnipttApiFp(this.configuration).retrieveSecret(retrieveSecretRequest, xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve vault keys
     * @param {RetrieveVaultKeysRequest} retrieveVaultKeysRequest 
     * @param {string} [xApiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnipttApi
     */
    public retrieveVaultKeys(retrieveVaultKeysRequest: RetrieveVaultKeysRequest, xApiKey?: string, options?: any) {
        return SnipttApiFp(this.configuration).retrieveVaultKeys(retrieveVaultKeysRequest, xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search Vault memberships
     * @param {SearchVaultMembershipsRequest} searchVaultMembershipsRequest 
     * @param {string} [xApiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnipttApi
     */
    public searchVaultMemberships(searchVaultMembershipsRequest: SearchVaultMembershipsRequest, xApiKey?: string, options?: any) {
        return SnipttApiFp(this.configuration).searchVaultMemberships(searchVaultMembershipsRequest, xApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send email verification code
     * @param {SendEmailVerificationCodeRequest} sendEmailVerificationCodeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnipttApi
     */
    public sendEmailVerificationCode(sendEmailVerificationCodeRequest: SendEmailVerificationCodeRequest, options?: any) {
        return SnipttApiFp(this.configuration).sendEmailVerificationCode(sendEmailVerificationCodeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


